/* Includes ------------------------------------------------------------------*/
#include "stdio.h"
#include "stdlib.h"
#include "string.h"

#include "app.h"

/* Private define ------------------------------------------------------------*/
#define 	LED_PORT 			GPIOA
#define 	LED_PIN 			GPIO_PIN_5

#define		LED1_PORT			GPIOA
#define		LED1_PIN			GPIO_PIN_6

#define		LED2_PORT			GPIOA
#define		LED2_PIN			GPIO_PIN_7

#define		LED3_PORT			GPIOB
#define		LED3_PIN			GPIO_PIN_6

#define 	LED_MODE_OFF		0 //These are just for LD2
#define 	LED_MODE_ON			1
#define 	LED_MODE_FLASHING	2

#define		LED_STATE_OFF		0 //These are for the distance sensor LEDs
#define		LED_STATE_ON		1
#define		LED_STATE_FLASHING	2

/* Private function prototypes -----------------------------------------------*/
void ShowCommands(void);
void UART_TransmitString(UART_HandleTypeDef *p_huart, char a_string[], int newline);
void DistanceLEDs(float mv);

/* Private variables ---------------------------------------------------------*/
extern TIM_HandleTypeDef htim2;
extern UART_HandleTypeDef huart2;
extern ADC_HandleTypeDef hadc1;

//Should be declared as volatile if variables' values are changed in ISR.
volatile char rxData;  //One byte data received from UART
volatile int ledMode = LED_MODE_FLASHING;
volatile int convend = 0;
volatile int takeSample = 0;

volatile int led1State = LED_STATE_OFF; //For distance sensor LEDs
volatile int led2State = LED_STATE_OFF;
volatile int led3State = LED_STATE_OFF;

void App_Init(void) {
/*
// If we want an intro message or instructions
	HAL_GPIO_WritePin(LED_PORT, LED_PIN, GPIO_PIN_SET);

	UART_TransmitString(&huart2, "-----------------", 1);
	UART_TransmitString(&huart2, "~ Nucleo-L476RG ~", 1);
	UART_TransmitString(&huart2, "-----------------", 1);

	ShowCommands();
*/
	HAL_TIM_Base_Start_IT(&htim2);
	HAL_UART_Receive_IT(&huart2, (uint8_t*) &rxData, 1); //Start the Rx interrupt.
	HAL_ADC_Start_IT(&hadc1);
}

void App_MainLoop(void) {
    uint32_t adcResult = 0;
    float mv;
    char strBuffer[10];

    while (1) {
        if (convend == 1) {
            convend = 0;

            adcResult = HAL_ADC_GetValue(&hadc1);

            mv = ((float) adcResult)*3300.0/0x0FFF;
            sprintf(strBuffer, "%7.2f", mv);
            UART_TransmitString(&huart2, "ADC result (mv): ", 0);
            UART_TransmitString(&huart2, strBuffer, 1);

            DistanceLEDs(mv);

        }
    }
}


void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *p_htim) {
	if (ledMode == LED_MODE_FLASHING) { //LD2
		HAL_GPIO_TogglePin(LED_PORT, LED_PIN);
	}

	if (led1State == LED_STATE_FLASHING) { //LED1
		HAL_GPIO_TogglePin(LED1_PORT, LED1_PIN);
	}

	if (led2State == LED_STATE_FLASHING) { //LED2
		HAL_GPIO_TogglePin(LED2_PORT, LED2_PIN);
	}

	if (led3State == LED_STATE_FLASHING) { //LED3
		HAL_GPIO_TogglePin(LED3_PORT, LED3_PIN);
	}

	HAL_ADC_Start_IT(&hadc1);
}

void HAL_UART_RxCpltCallback(UART_HandleTypeDef *p_huart) {
	//Process the data received from UART.
	//If we wanted to use Putty for any commands, the layout is here
	/*
	switch (rxData) {
	case 'I':
	case 'i':
		HAL_GPIO_WritePin(LED_PORT, LED_PIN, GPIO_PIN_SET);
		ledMode = LED_MODE_ON;
		break;
	case 'O':
	case 'o':
		HAL_GPIO_WritePin(LED_PORT, LED_PIN, GPIO_PIN_RESET);
		ledMode = LED_MODE_OFF;
		break;
	case 'F':
	case 'f':
		ledMode = LED_MODE_FLASHING;
		break;
	case 'H':
	case 'h':
		ShowCommands();
		break;
	case 'S':
	case 's':
		HAL_ADC_Start_IT(&hadc1);
		break;
	}
	*/
	HAL_UART_Receive_IT(p_huart, (uint8_t*) &rxData, 1); //Restart the Rx interrupt.
}

/*
// If we wanted callable intructions
void ShowCommands(void) {
	UART_TransmitString(&huart2, "Type on keyboard to send command from PC to MCU:", 1);
	UART_TransmitString(&huart2, "> I: turn on LED, O: turn off LED, F: flashing LED, H: show commands", 1);
	UART_TransmitString(&huart2, "> S: sample ADC", 1);
}
*/

void UART_TransmitString(UART_HandleTypeDef *p_huart, char a_string[], int newline) {
	HAL_UART_Transmit(p_huart, (uint8_t*) a_string, strlen(a_string), HAL_MAX_DELAY);
	if (newline != 0) {
		HAL_UART_Transmit(p_huart, (uint8_t*) "\n\r", 2, HAL_MAX_DELAY);
	}
}

void HAL_ADC_ConvCpltCallback(ADC_HandleTypeDef *p_hadc1) {
    convend = 1;
}

void DistanceLEDs(float mv) {
	if (mv <= 550.0f) {
	    led1State = LED_STATE_ON;
	    led2State = LED_STATE_OFF;
	    led3State = LED_STATE_OFF;
	}
	else if (mv > 550.0f && mv <= 700.0f) {
		led1State = LED_STATE_ON;
		led2State = LED_STATE_FLASHING;
		led3State = LED_STATE_OFF;
	}
	else if (mv > 700.0f && mv <= 950.0f) {
		led1State = LED_STATE_OFF;
		led2State = LED_STATE_ON;
		led3State = LED_STATE_OFF;
	}
	else if (mv > 950.0f && mv <= 1860.0f) {
		led1State = LED_STATE_OFF;
		led2State = LED_STATE_ON;
		led3State = LED_STATE_FLASHING;
	}
	else {
		led1State = LED_STATE_OFF;
		led2State = LED_STATE_OFF;
		led3State = LED_STATE_ON;
	}


	if (led1State == LED_STATE_ON) {
	    HAL_GPIO_WritePin(LED1_PORT, LED1_PIN, GPIO_PIN_SET);
	}
	else if (led1State == LED_STATE_OFF) {
	    HAL_GPIO_WritePin(LED1_PORT, LED1_PIN, GPIO_PIN_RESET);
	}

	if (led2State == LED_STATE_ON) {
	    HAL_GPIO_WritePin(LED2_PORT, LED2_PIN, GPIO_PIN_SET);
	}
	else if (led2State == LED_STATE_OFF) {
	    HAL_GPIO_WritePin(LED2_PORT, LED2_PIN, GPIO_PIN_RESET);
	}

	if (led3State == LED_STATE_ON) {
	    HAL_GPIO_WritePin(LED3_PORT, LED3_PIN, GPIO_PIN_SET);
	}
	else if (led3State == LED_STATE_OFF) {
	    HAL_GPIO_WritePin(LED3_PORT, LED3_PIN, GPIO_PIN_RESET);
	}
}
